package mergex

import (
	"sort"
	"testing"

	"github.com/CycloneDX/cyclonedx-go"
	"github.com/stretchr/testify/assert"
)

func TestMergeVulnerability(t *testing.T) {
	t.Run("merge vulnerabilities with same BOMRef", func(t *testing.T) {
		a := cyclonedx.Vulnerability{
			BOMRef:      "vuln-a",
			ID:          "CVE-2023-1234",
			Description: "First vulnerability description",
			Detail:      "Detailed information about vuln A",
			Created:     "2023-01-01T00:00:00Z",
			CWEs:        &[]int{79, 89},
			Properties: &[]cyclonedx.Property{
				{Name: "source", Value: "nvd"},
				{Name: "severity", Value: "high"},
			},
		}
		b := cyclonedx.Vulnerability{
			BOMRef:         "vuln-a",
			ID:             "CVE-2023-5678", // Should not override first
			Description:    "Second vulnerability description", // Should not override first
			Recommendation: "Update to latest version", // Should be filled from second
			Published:      "2023-02-01T00:00:00Z", // Should be filled from second
			CWEs:           &[]int{89, 120}, // 89 is duplicate
			Properties: &[]cyclonedx.Property{
				{Name: "severity", Value: "critical"}, // duplicate key - first should win
				{Name: "priority", Value: "p1"},       // new key
			},
		}

		result := mergeVulnerability(a, b)

		assert.Equal(t, "vuln-a", result.BOMRef)
		assert.Equal(t, "CVE-2023-1234", result.ID) // First input wins
		assert.Equal(t, "First vulnerability description", result.Description) // First input wins
		assert.Equal(t, "Detailed information about vuln A", result.Detail) // From first
		assert.Equal(t, "Update to latest version", result.Recommendation) // Filled from second
		assert.Equal(t, "2023-01-01T00:00:00Z", result.Created) // From first
		assert.Equal(t, "2023-02-01T00:00:00Z", result.Published) // Filled from second

		// Check CWEs are merged and deduplicated
		assert.NotNil(t, result.CWEs)
		cwes := *result.CWEs
		sort.Ints(cwes)
		assert.Len(t, cwes, 3)
		assert.Contains(t, cwes, 79)
		assert.Contains(t, cwes, 89)
		assert.Contains(t, cwes, 120)

		// Check properties are merged by key
		assert.NotNil(t, result.Properties)
		assert.Len(t, *result.Properties, 3) // 3 unique keys

		propMap := make(map[string]string)
		for _, prop := range *result.Properties {
			propMap[prop.Name] = prop.Value
		}
		assert.Equal(t, "nvd", propMap["source"])
		assert.Equal(t, "high", propMap["severity"]) // First input wins
		assert.Equal(t, "p1", propMap["priority"])
	})

	t.Run("merge vulnerabilities with nil fields", func(t *testing.T) {
		a := cyclonedx.Vulnerability{
			BOMRef:      "vuln-a",
			ID:          "CVE-2023-1234",
			Description: "First vulnerability",
			CWEs:        &[]int{79},
			Properties:  nil,
		}
		b := cyclonedx.Vulnerability{
			BOMRef:         "vuln-a",
			ID:             "CVE-2023-5678",
			Description:    "Second vulnerability",
			Recommendation: "Update immediately",
			CWEs:           nil,
			Properties: &[]cyclonedx.Property{
				{Name: "source", Value: "github"},
			},
		}

		result := mergeVulnerability(a, b)

		assert.Equal(t, "vuln-a", result.BOMRef)
		assert.Equal(t, "CVE-2023-1234", result.ID) // First input wins
		assert.Equal(t, "First vulnerability", result.Description) // First input wins
		assert.Equal(t, "Update immediately", result.Recommendation) // Filled from second

		// CWEs from first should be preserved
		assert.NotNil(t, result.CWEs)
		assert.Equal(t, []int{79}, *result.CWEs)

		// Properties from second should be included
		assert.NotNil(t, result.Properties)
		assert.Len(t, *result.Properties, 1)
		assert.Equal(t, "source", (*result.Properties)[0].Name)
		assert.Equal(t, "github", (*result.Properties)[0].Value)
	})

	t.Run("merge vulnerabilities with empty fields", func(t *testing.T) {
		a := cyclonedx.Vulnerability{
			BOMRef: "vuln-a",
			ID:     "CVE-2023-1234",
			// Description empty - should be filled from b
			CWEs: &[]int{},
		}
		b := cyclonedx.Vulnerability{
			BOMRef:      "vuln-a",
			ID:          "CVE-2023-5678",
			Description: "Filled from second",
			CWEs:        &[]int{},
		}

		result := mergeVulnerability(a, b)

		assert.Equal(t, "vuln-a", result.BOMRef)
		assert.Equal(t, "CVE-2023-1234", result.ID) // First input wins
		assert.Equal(t, "Filled from second", result.Description) // Filled from second
		assert.Nil(t, result.CWEs) // Empty arrays result in nil
	})
}

func TestMergeVulnerabilitySlice(t *testing.T) {
	t.Run("both nil", func(t *testing.T) {
		result := mergeVulnerabilitySlice(nil, nil)
		assert.Nil(t, result)
	})

	t.Run("first nil, second has values", func(t *testing.T) {
		b := &[]cyclonedx.Vulnerability{
			{
				BOMRef:      "vuln-b",
				ID:          "CVE-2023-5678",
				Description: "Vulnerability B",
				CWEs:        &[]int{120},
			},
		}

		result := mergeVulnerabilitySlice(nil, b)

		assert.NotNil(t, result)
		assert.Len(t, *result, 1)
		assert.Equal(t, "vuln-b", (*result)[0].BOMRef)
		assert.Equal(t, "CVE-2023-5678", (*result)[0].ID)
		assert.Equal(t, "Vulnerability B", (*result)[0].Description)
		assert.Equal(t, []int{120}, *(*result)[0].CWEs)
	})

	t.Run("merge slices with no overlapping BOMRefs", func(t *testing.T) {
		a := &[]cyclonedx.Vulnerability{
			{
				BOMRef:      "vuln-a",
				ID:          "CVE-2023-1234",
				Description: "Vulnerability A",
				CWEs:        &[]int{79, 89},
			},
		}
		b := &[]cyclonedx.Vulnerability{
			{
				BOMRef:      "vuln-b",
				ID:          "CVE-2023-5678",
				Description: "Vulnerability B",
				CWEs:        &[]int{120, 200},
			},
		}

		result := mergeVulnerabilitySlice(a, b)

		assert.NotNil(t, result)
		assert.Len(t, *result, 2)

		// Convert to map for easier testing since order is not guaranteed
		vulnMap := make(map[string]cyclonedx.Vulnerability)
		for _, vuln := range *result {
			vulnMap[vuln.BOMRef] = vuln
		}

		assert.Equal(t, "CVE-2023-1234", vulnMap["vuln-a"].ID)
		assert.Equal(t, "Vulnerability A", vulnMap["vuln-a"].Description)
		assert.Equal(t, []int{79, 89}, *vulnMap["vuln-a"].CWEs)

		assert.Equal(t, "CVE-2023-5678", vulnMap["vuln-b"].ID)
		assert.Equal(t, "Vulnerability B", vulnMap["vuln-b"].Description)
		assert.Equal(t, []int{120, 200}, *vulnMap["vuln-b"].CWEs)
	})

	t.Run("merge slices with overlapping BOMRefs", func(t *testing.T) {
		a := &[]cyclonedx.Vulnerability{
			{
				BOMRef:      "vuln-a",
				ID:          "CVE-2023-1234",
				Description: "Vulnerability A",
				CWEs:        &[]int{79, 89},
				Properties: &[]cyclonedx.Property{
					{Name: "source", Value: "nvd"},
				},
			},
			{
				BOMRef:      "vuln-b",
				ID:          "CVE-2023-2222",
				Description: "Vulnerability B",
			},
		}
		b := &[]cyclonedx.Vulnerability{
			{
				BOMRef:         "vuln-a", // Same BOMRef as first
				ID:             "CVE-2023-9999", // Should not override
				Description:    "Different description", // Should not override
				Recommendation: "Update now", // Should be filled
				CWEs:           &[]int{89, 120}, // 89 is duplicate
				Properties: &[]cyclonedx.Property{
					{Name: "source", Value: "github"}, // duplicate key - first should win
					{Name: "priority", Value: "high"}, // new key
				},
			},
			{
				BOMRef:      "vuln-c",
				ID:          "CVE-2023-3333",
				Description: "Vulnerability C",
			},
		}

		result := mergeVulnerabilitySlice(a, b)

		assert.NotNil(t, result)
		assert.Len(t, *result, 3) // vuln-a merged, vuln-b and vuln-c separate

		// Convert to map for easier testing since order is not guaranteed
		vulnMap := make(map[string]cyclonedx.Vulnerability)
		for _, vuln := range *result {
			vulnMap[vuln.BOMRef] = vuln
		}

		// vuln-a should have merged fields
		assert.Equal(t, "CVE-2023-1234", vulnMap["vuln-a"].ID) // First input wins
		assert.Equal(t, "Vulnerability A", vulnMap["vuln-a"].Description) // First input wins
		assert.Equal(t, "Update now", vulnMap["vuln-a"].Recommendation) // Filled from second

		// Check CWEs are merged and deduplicated
		cwes := *vulnMap["vuln-a"].CWEs
		sort.Ints(cwes)
		assert.Equal(t, []int{79, 89, 120}, cwes)

		// Check properties are merged by key
		propMap := make(map[string]string)
		for _, prop := range *vulnMap["vuln-a"].Properties {
			propMap[prop.Name] = prop.Value
		}
		assert.Equal(t, "nvd", propMap["source"]) // First input wins
		assert.Equal(t, "high", propMap["priority"]) // From second

		// vuln-b should remain unchanged
		assert.Equal(t, "CVE-2023-2222", vulnMap["vuln-b"].ID)
		assert.Equal(t, "Vulnerability B", vulnMap["vuln-b"].Description)

		// vuln-c should be added as-is
		assert.Equal(t, "CVE-2023-3333", vulnMap["vuln-c"].ID)
		assert.Equal(t, "Vulnerability C", vulnMap["vuln-c"].Description)
	})

	t.Run("empty slices", func(t *testing.T) {
		a := &[]cyclonedx.Vulnerability{}
		b := &[]cyclonedx.Vulnerability{}

		result := mergeVulnerabilitySlice(a, b)

		assert.Nil(t, result)
	})
}

func TestMergeIntSlice(t *testing.T) {
	t.Run("both nil", func(t *testing.T) {
		result := mergeIntSlice(nil, nil)
		assert.Nil(t, result)
	})

	t.Run("no duplicates", func(t *testing.T) {
		a := &[]int{79, 89}
		b := &[]int{120, 200}

		result := mergeIntSlice(a, b)

		assert.NotNil(t, result)
		assert.Len(t, *result, 4)

		// Sort for predictable testing
		ints := *result
		sort.Ints(ints)
		assert.Equal(t, []int{79, 89, 120, 200}, ints)
	})

	t.Run("with duplicates", func(t *testing.T) {
		a := &[]int{79, 89, 120}
		b := &[]int{89, 120, 200}

		result := mergeIntSlice(a, b)

		assert.NotNil(t, result)
		assert.Len(t, *result, 4) // 89 and 120 are deduplicated

		// Sort for predictable testing
		ints := *result
		sort.Ints(ints)
		assert.Equal(t, []int{79, 89, 120, 200}, ints)
	})

	t.Run("first nil, second has values", func(t *testing.T) {
		b := &[]int{79, 89}

		result := mergeIntSlice(nil, b)

		assert.NotNil(t, result)
		assert.Len(t, *result, 2)

		// Sort for predictable testing
		ints := *result
		sort.Ints(ints)
		assert.Equal(t, []int{79, 89}, ints)
	})

	t.Run("both empty", func(t *testing.T) {
		a := &[]int{}
		b := &[]int{}

		result := mergeIntSlice(a, b)

		assert.Nil(t, result)
	})

	t.Run("complete duplicates", func(t *testing.T) {
		a := &[]int{79, 89}
		b := &[]int{79, 89}

		result := mergeIntSlice(a, b)

		assert.NotNil(t, result)
		assert.Len(t, *result, 2)

		// Sort for predictable testing
		ints := *result
		sort.Ints(ints)
		assert.Equal(t, []int{79, 89}, ints)
	})
}

func TestMergeVulnerabilitySlice_Immutability(t *testing.T) {
	t.Run("original slices are not modified", func(t *testing.T) {
		originalA := &[]cyclonedx.Vulnerability{
			{
				BOMRef:      "vuln-a",
				ID:          "CVE-2023-1234",
				Description: "Vulnerability A",
				CWEs:        &[]int{79, 89},
				Properties: &[]cyclonedx.Property{
					{Name: "source", Value: "nvd"},
				},
			},
		}
		originalB := &[]cyclonedx.Vulnerability{
			{
				BOMRef:         "vuln-a", // Same BOMRef for merging
				ID:             "CVE-2023-5678",
				Recommendation: "Update now",
				CWEs:           &[]int{120, 200},
				Properties: &[]cyclonedx.Property{
					{Name: "priority", Value: "high"},
				},
			},
		}

		// Create copies for comparison
		copyA := &[]cyclonedx.Vulnerability{
			{
				BOMRef:      (*originalA)[0].BOMRef,
				ID:          (*originalA)[0].ID,
				Description: (*originalA)[0].Description,
				CWEs:        &[]int{(*(*originalA)[0].CWEs)[0], (*(*originalA)[0].CWEs)[1]},
				Properties: &[]cyclonedx.Property{
					{Name: (*(*originalA)[0].Properties)[0].Name, Value: (*(*originalA)[0].Properties)[0].Value},
				},
			},
		}
		copyB := &[]cyclonedx.Vulnerability{
			{
				BOMRef:         (*originalB)[0].BOMRef,
				ID:             (*originalB)[0].ID,
				Recommendation: (*originalB)[0].Recommendation,
				CWEs:           &[]int{(*(*originalB)[0].CWEs)[0], (*(*originalB)[0].CWEs)[1]},
				Properties: &[]cyclonedx.Property{
					{Name: (*(*originalB)[0].Properties)[0].Name, Value: (*(*originalB)[0].Properties)[0].Value},
				},
			},
		}

		result := mergeVulnerabilitySlice(originalA, originalB)

		// Verify original inputs were not modified
		assert.Equal(t, (*copyA)[0].BOMRef, (*originalA)[0].BOMRef)
		assert.Equal(t, (*copyA)[0].ID, (*originalA)[0].ID)
		assert.Equal(t, (*copyA)[0].Description, (*originalA)[0].Description)
		assert.Equal(t, *(*copyA)[0].CWEs, *(*originalA)[0].CWEs)
		assert.Equal(t, (*(*copyA)[0].Properties)[0].Name, (*(*originalA)[0].Properties)[0].Name)

		assert.Equal(t, (*copyB)[0].BOMRef, (*originalB)[0].BOMRef)
		assert.Equal(t, (*copyB)[0].ID, (*originalB)[0].ID)
		assert.Equal(t, (*copyB)[0].Recommendation, (*originalB)[0].Recommendation)
		assert.Equal(t, *(*copyB)[0].CWEs, *(*originalB)[0].CWEs)
		assert.Equal(t, (*(*copyB)[0].Properties)[0].Name, (*(*originalB)[0].Properties)[0].Name)

		// Verify result is merged correctly
		assert.NotNil(t, result)
		assert.Len(t, *result, 1) // One merged vulnerability
		assert.Equal(t, "vuln-a", (*result)[0].BOMRef)
		assert.Equal(t, "CVE-2023-1234", (*result)[0].ID) // First input wins

		// Both CWE arrays should be merged in result
		assert.NotNil(t, (*result)[0].CWEs)
		assert.Len(t, *(*result)[0].CWEs, 4) // All unique CWEs

		// Both property arrays should be merged in result
		assert.NotNil(t, (*result)[0].Properties)
		assert.Len(t, *(*result)[0].Properties, 2) // All unique properties
	})
}