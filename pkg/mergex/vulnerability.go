package mergex

import (
	"github.com/CycloneDX/cyclonedx-go"
)

// mergeVulnerability merges two cyclonedx.Vulnerability structs non-destructively.
// Since BOMRef is a unique identifier, this function assumes both vulnerabilities have the same BOMRef.
// For non-array fields, the first input takes precedence.
// For array fields, items from both inputs are combined.
// Returns a new Vulnerability struct without modifying the inputs.
func mergeVulnerability(a, b cyclonedx.Vulnerability) cyclonedx.Vulnerability {
	result := cyclonedx.Vulnerability{
		BOMRef: a.BOMRef, // Both should have the same BOMRef, use first input
		ID:     a.ID,     // First input wins
	}

	// Fill empty simple fields from b where a is empty
	if a.Description == "" {
		result.Description = b.Description
	} else {
		result.Description = a.Description
	}
	if a.Detail == "" {
		result.Detail = b.Detail
	} else {
		result.Detail = a.Detail
	}
	if a.Recommendation == "" {
		result.Recommendation = b.Recommendation
	} else {
		result.Recommendation = a.Recommendation
	}
	if a.Workaround == "" {
		result.Workaround = b.Workaround
	} else {
		result.Workaround = a.Workaround
	}
	if a.Created == "" {
		result.Created = b.Created
	} else {
		result.Created = a.Created
	}
	if a.Published == "" {
		result.Published = b.Published
	} else {
		result.Published = a.Published
	}
	if a.Updated == "" {
		result.Updated = b.Updated
	} else {
		result.Updated = a.Updated
	}
	if a.Rejected == "" {
		result.Rejected = b.Rejected
	} else {
		result.Rejected = a.Rejected
	}

	// Merge complex fields
	if a.Source == nil {
		result.Source = copySource(b.Source)
	} else if b.Source != nil {
		result.Source = mergeSource(a.Source, b.Source)
	} else {
		result.Source = copySource(a.Source)
	}

	if a.ProofOfConcept == nil {
		result.ProofOfConcept = copyProofOfConcept(b.ProofOfConcept)
	} else if b.ProofOfConcept != nil {
		result.ProofOfConcept = mergeProofOfConcept(a.ProofOfConcept, b.ProofOfConcept)
	} else {
		result.ProofOfConcept = copyProofOfConcept(a.ProofOfConcept)
	}

	if a.Credits == nil {
		result.Credits = copyCredits(b.Credits)
	} else if b.Credits != nil {
		result.Credits = mergeCredits(a.Credits, b.Credits)
	} else {
		result.Credits = copyCredits(a.Credits)
	}

	if a.Tools == nil {
		result.Tools = copyToolsChoice(b.Tools)
	} else if b.Tools != nil {
		result.Tools = mergeToolsChoice(a.Tools, b.Tools)
	} else {
		result.Tools = copyToolsChoice(a.Tools)
	}

	if a.Analysis == nil {
		result.Analysis = copyVulnerabilityAnalysis(b.Analysis)
	} else if b.Analysis != nil {
		result.Analysis = mergeVulnerabilityAnalysis(a.Analysis, b.Analysis)
	} else {
		result.Analysis = copyVulnerabilityAnalysis(a.Analysis)
	}

	// Merge array fields
	result.References = mergeVulnerabilityReferenceSlice(a.References, b.References)
	result.Ratings = mergeVulnerabilityRatingSlice(a.Ratings, b.Ratings)
	result.CWEs = mergeIntSlice(a.CWEs, b.CWEs)
	result.Advisories = mergeAdvisorySlice(a.Advisories, b.Advisories)
	result.Affects = mergeAffectsSlice(a.Affects, b.Affects)
	result.Properties = mergePropertySlice(a.Properties, b.Properties)

	return result
}

// mergeVulnerabilitySlice merges two Vulnerability slices non-destructively.
// Vulnerabilities with the same BOMRef are merged together.
// Vulnerabilities with unique BOMRefs are included as-is.
// Returns a new slice without modifying the inputs.
func mergeVulnerabilitySlice(a, b *[]cyclonedx.Vulnerability) *[]cyclonedx.Vulnerability {
	if a == nil && b == nil {
		return nil
	}

	// Use map to track vulnerabilities by BOMRef
	vulnMap := make(map[string]cyclonedx.Vulnerability)

	// First add all vulnerabilities from a
	if a != nil {
		for _, vuln := range *a {
			vulnMap[vuln.BOMRef] = vuln
		}
	}

	// Then process vulnerabilities from b
	if b != nil {
		for _, vuln := range *b {
			if existing, exists := vulnMap[vuln.BOMRef]; exists {
				// Merge with existing vulnerability (same BOMRef)
				vulnMap[vuln.BOMRef] = mergeVulnerability(existing, vuln)
			} else {
				// Add new vulnerability (unique BOMRef)
				vulnMap[vuln.BOMRef] = vuln
			}
		}
	}

	if len(vulnMap) == 0 {
		return nil
	}

	// Convert back to slice
	result := make([]cyclonedx.Vulnerability, 0, len(vulnMap))
	for _, vuln := range vulnMap {
		result = append(result, vuln)
	}

	return &result
}

// Helper copy and merge functions for complex types (simplified implementations)
// These would need full implementations in a production system

func copySource(source *cyclonedx.Source) *cyclonedx.Source {
	if source == nil {
		return nil
	}
	// Deep copy implementation would be needed
	copy := *source
	return &copy
}

func mergeSource(a, b *cyclonedx.Source) *cyclonedx.Source {
	// First input wins for now - proper merge logic would be needed
	copy := *a
	return &copy
}

func copyProofOfConcept(poc *cyclonedx.ProofOfConcept) *cyclonedx.ProofOfConcept {
	if poc == nil {
		return nil
	}
	copy := *poc
	return &copy
}

func mergeProofOfConcept(a, b *cyclonedx.ProofOfConcept) *cyclonedx.ProofOfConcept {
	// First input wins for now - proper merge logic would be needed
	copy := *a
	return &copy
}

func copyCredits(credits *cyclonedx.Credits) *cyclonedx.Credits {
	if credits == nil {
		return nil
	}
	copy := *credits
	return &copy
}

func mergeCredits(a, b *cyclonedx.Credits) *cyclonedx.Credits {
	// First input wins for now - proper merge logic would be needed
	copy := *a
	return &copy
}

func copyVulnerabilityAnalysis(analysis *cyclonedx.VulnerabilityAnalysis) *cyclonedx.VulnerabilityAnalysis {
	if analysis == nil {
		return nil
	}
	copy := *analysis
	return &copy
}

func mergeVulnerabilityAnalysis(a, b *cyclonedx.VulnerabilityAnalysis) *cyclonedx.VulnerabilityAnalysis {
	// First input wins for now - proper merge logic would be needed
	copy := *a
	return &copy
}

// Helper merge functions for array types
func mergeVulnerabilityReferenceSlice(a, b *[]cyclonedx.VulnerabilityReference) *[]cyclonedx.VulnerabilityReference {
	if a == nil && b == nil {
		return nil
	}

	var result []cyclonedx.VulnerabilityReference

	if a != nil {
		result = append(result, *a...)
	}
	if b != nil {
		result = append(result, *b...)
	}

	if len(result) == 0 {
		return nil
	}

	return &result
}

func mergeVulnerabilityRatingSlice(a, b *[]cyclonedx.VulnerabilityRating) *[]cyclonedx.VulnerabilityRating {
	if a == nil && b == nil {
		return nil
	}

	var result []cyclonedx.VulnerabilityRating

	if a != nil {
		result = append(result, *a...)
	}
	if b != nil {
		result = append(result, *b...)
	}

	if len(result) == 0 {
		return nil
	}

	return &result
}

func mergeIntSlice(a, b *[]int) *[]int {
	if a == nil && b == nil {
		return nil
	}

	// Use map to deduplicate integers
	intMap := make(map[int]bool)

	if a != nil {
		for _, val := range *a {
			intMap[val] = true
		}
	}
	if b != nil {
		for _, val := range *b {
			intMap[val] = true
		}
	}

	if len(intMap) == 0 {
		return nil
	}

	result := make([]int, 0, len(intMap))
	for val := range intMap {
		result = append(result, val)
	}

	return &result
}

func mergeAdvisorySlice(a, b *[]cyclonedx.Advisory) *[]cyclonedx.Advisory {
	if a == nil && b == nil {
		return nil
	}

	var result []cyclonedx.Advisory

	if a != nil {
		result = append(result, *a...)
	}
	if b != nil {
		result = append(result, *b...)
	}

	if len(result) == 0 {
		return nil
	}

	return &result
}

func mergeAffectsSlice(a, b *[]cyclonedx.Affects) *[]cyclonedx.Affects {
	if a == nil && b == nil {
		return nil
	}

	var result []cyclonedx.Affects

	if a != nil {
		result = append(result, *a...)
	}
	if b != nil {
		result = append(result, *b...)
	}

	if len(result) == 0 {
		return nil
	}

	return &result
}

func copyVulnerabilitySlice(vulnerabilities *[]cyclonedx.Vulnerability) *[]cyclonedx.Vulnerability {
	if vulnerabilities == nil {
		return nil
	}
	result := make([]cyclonedx.Vulnerability, len(*vulnerabilities))
	copy(result, *vulnerabilities)
	return &result
}